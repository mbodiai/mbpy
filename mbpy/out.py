# generated by datamodel-codegen:
#   filename:  mypy.json
#   timestamp: 2024-11-17T16:15:13+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional, Union

from pydantic import BaseModel, Extra, Field


class FollowImports(Enum):
    normal = 'normal'
    silent = 'silent'
    skip = 'skip'
    error = 'error'


class AllowRedefinition(BaseModel):
    __root__: bool = Field(
        ...,
        description='Allows variables to be redefined with an arbitrary type, as long as the redefinition is in the same block and nesting level as the original definition.',
    )


class AllowUntypedGlobals(BaseModel):
    __root__: bool = Field(
        ...,
        description='Causes mypy to suppress errors caused by not being able to fully infer the types of global and class variables.',
    )


class AlwaysFalse(BaseModel):
    __root__: Union[str, List[str]] = Field(
        ...,
        description='Specifies a list of variables that mypy will treat as compile-time constants that are always false.',
    )


class AlwaysTrue(BaseModel):
    __root__: Union[str, List[str]] = Field(
        ...,
        description='Specifies a list of variables that mypy will treat as compile-time constants that are always true.',
    )


class AnyExprsReport(BaseModel):
    __root__: str = Field(
        ...,
        description='Causes mypy to generate a text file report documenting how many expressions of type `Any` are present within your codebase.',
    )


class CacheDir(BaseModel):
    __root__: str = Field(
        ...,
        description='Specifies the location where mypy stores incremental cache info. User home directory and environment variables will be expanded. This setting will be overridden by the `MYPY_CACHE_DIR` environment variable.',
    )


class CacheFineGrained(BaseModel):
    __root__: bool = Field(
        ...,
        description='Include fine-grained dependency information in the cache for the mypy daemon (https://mypy.readthedocs.io/en/stable/mypy_daemon.html).',
    )


class CheckUntypedDefs(BaseModel):
    __root__: bool = Field(
        ...,
        description='Type-checks the interior of functions without type annotations.',
    )


class CoberturaXmlReport(BaseModel):
    __root__: str = Field(
        ...,
        description='Causes mypy to generate a Cobertura XML type checking coverage report.',
    )


class ColorOutput(BaseModel):
    __root__: bool = Field(..., description='Shows error messages with color enabled.')


class CustomTypeshedDir(BaseModel):
    __root__: str = Field(
        ...,
        description='This specifies the directory where mypy looks for standard library typeshed stubs, instead of the typeshed that ships with mypy. This is primarily intended to make it easier to test typeshed changes before submitting them upstream, but also allows you to use a forked version of typeshed.',
    )


class CustomTypingModule(BaseModel):
    __root__: str = Field(
        ...,
        description='Specifies a custom module to use as a substitute for the `typing` module.',
    )


class DisableErrorCode(BaseModel):
    __root__: Union[str, List[str]] = Field(
        ..., description='Allows disabling one or multiple error codes globally.'
    )


class DisallowAnyDecorated(BaseModel):
    __root__: bool = Field(
        ...,
        description='Disallows functions that have `Any` in their signature after decorator transformation.',
    )


class DisallowAnyExplicit(BaseModel):
    __root__: bool = Field(
        ...,
        description='Disallows explicit `Any` in type positions such as type annotations and generic type parameters.',
    )


class DisallowAnyExpr(BaseModel):
    __root__: bool = Field(
        ..., description='Disallows all expressions in the module that have type `Any`.'
    )


class DisallowAnyGenerics(BaseModel):
    __root__: bool = Field(
        ...,
        description='Disallows usage of generic types that do not specify explicit type parameters.',
    )


class DisallowAnyUnimported(BaseModel):
    __root__: bool = Field(
        ...,
        description='Disallows usage of types that come from unfollowed imports (anything imported from an unfollowed import is automatically given a type of `Any`).',
    )


class DisallowIncompleteDefs(BaseModel):
    __root__: bool = Field(
        ...,
        description='Disallows defining functions with incomplete type annotations, while still allowing entirely unannotated definitions.',
    )


class DisallowSubclassingAny(BaseModel):
    __root__: bool = Field(
        ..., description='Disallows subclassing a value of type `Any`.'
    )


class DisallowUntypedCalls(BaseModel):
    __root__: bool = Field(
        ...,
        description='Disallows calling functions without type annotations from functions with type annotations. Note that when used in per-module options, it enables/disables this check INSIDE the module(s) specified, not for functions that come from that module(s).',
    )


class DisallowUntypedDecorators(BaseModel):
    __root__: bool = Field(
        ...,
        description='Reports an error whenever a function with type annotations is decorated with a decorator without annotations.',
    )


class DisallowUntypedDefs(BaseModel):
    __root__: bool = Field(
        ...,
        description='Disallows defining functions without type annotations or with incomplete type annotations (a superset of `disallow_incomplete_defs`).',
    )


class EnableErrorCode(BaseModel):
    __root__: Union[str, List[str]] = Field(
        ..., description='Allows enabling one or multiple error codes globally.'
    )


class ErrorSummary(BaseModel):
    __root__: bool = Field(
        ..., description='Shows a short summary line after error messages.'
    )


class FollowImportsForStubs(BaseModel):
    __root__: bool = Field(
        ...,
        description='Determines whether to respect the `follow_imports` setting even for stub (`.pyi`) files.',
    )


class ForceUnionSyntax(BaseModel):
    __root__: bool = Field(
        ...,
        description='Always use `Union[]` and `Optional[]` for union types in error messages (instead of the `|` operator), even on Python 3.10+.',
    )


class ForceUppercaseBuiltins(BaseModel):
    __root__: bool = Field(
        ...,
        description='Always use `List` instead of `list` in error messages, even on Python 3.9+.',
    )


class HideErrorCodes(BaseModel):
    __root__: bool = Field(
        ...,
        description='Hides error codes (https://mypy.readthedocs.io/en/stable/error_codes.html#error-codes) in error messages.',
    )


class IgnoreErrors(BaseModel):
    __root__: bool = Field(..., description='Ignores all non-fatal errors.')


class IgnoreMissingImports(BaseModel):
    __root__: bool = Field(
        ...,
        description='Suppresses error messages about imports that cannot be resolved.',
    )


class ImplicitOptional(BaseModel):
    __root__: bool = Field(
        ...,
        description='Causes mypy to treat arguments with a `None` default value as having an implicit `typing.Optional` type.',
    )


class ImplicitReexport(BaseModel):
    __root__: bool = Field(
        ...,
        description='By default, imported values to a module are treated as exported and mypy allows other modules to import them. When false, mypy will not re-export unless the item is imported using from-as or is included in `__all__`. Note that mypy treats stub files as if this is always disabled.',
    )


class Incremental(BaseModel):
    __root__: bool = Field(
        ...,
        description='Enables incremental mode (https://mypy.readthedocs.io/en/stable/command_line.html#incremental).',
    )


class JunitXml(BaseModel):
    __root__: str = Field(
        ...,
        description='Causes mypy to generate a JUnit XML test result document with type checking results. This can make it easier to integrate mypy with continuous integration (CI) tools.',
    )


class LinecountReport(BaseModel):
    __root__: str = Field(
        ...,
        description='Causes mypy to generate a text file report documenting the functions and lines that are typed and untyped within your codebase.',
    )


class LinecoverageReport(BaseModel):
    __root__: str = Field(
        ...,
        description="Causes mypy to generate a JSON file that maps each source file's absolute filename to a list of line numbers that belong to typed functions in that file.",
    )


class LineprecisionReport(BaseModel):
    __root__: str = Field(
        ...,
        description='Causes mypy to generate a flat text file report with per-module statistics of how many lines are typechecked etc.',
    )


class LocalPartialTypes(BaseModel):
    __root__: bool = Field(
        ...,
        description='Disallows inferring variable type for `None` from two assignments in different scopes. This is always implicitly enabled when using the mypy daemon (https://mypy.readthedocs.io/en/stable/mypy_daemon.html).',
    )


class NoImplicitOptional(BaseModel):
    __root__: bool = Field(..., description='Inverse of implicit_optional.')


class NoImplicitReexport(BaseModel):
    __root__: bool = Field(
        ...,
        description='By default, imported values to a module are treated as exported and mypy allows other modules to import them. This flag changes the behavior to not re-export unless the item is imported using from-as or is included in `__all__`. Note this is always treated as enabled for stub files.',
    )


class NoSitePackages(BaseModel):
    __root__: bool = Field(
        ...,
        description='Disables using type information in installed packages (see PEP 561). This will also disable searching for a usable Python executable. This acts the same as :option:`--no-site-packages <mypy --no-site-packages>` command line flag.',
    )


class Pdb(BaseModel):
    __root__: bool = Field(
        ...,
        description='Invokes `pdb` (https://docs.python.org/3/library/pdb.html) on fatal error.',
    )


class Plugins(BaseModel):
    __root__: Union[str, List[str]] = Field(
        ..., description='A comma-separated list of mypy plugins.'
    )


class Pretty(BaseModel):
    __root__: bool = Field(
        ...,
        description='Use visually nicer output in error messages: use soft word wrap, show source code snippets, and show error location markers.',
    )


class RaiseExceptions(BaseModel):
    __root__: bool = Field(..., description='Raise exception on fatal error.')


class ScriptsAreModules(BaseModel):
    __root__: bool = Field(
        ...,
        description='Makes script `x` become module `x` instead of `__main__`. This is useful when checking multiple scripts in a single run.',
    )


class ShowAbsolutePath(BaseModel):
    __root__: bool = Field(..., description='Show absolute paths to files.')


class ShowColumnNumbers(BaseModel):
    __root__: bool = Field(..., description='Shows column numbers in error messages.')


class ShowErrorContext(BaseModel):
    __root__: bool = Field(
        ..., description='Prefixes each error with the relevant context.'
    )


class ShowTraceback(BaseModel):
    __root__: bool = Field(..., description='Shows traceback on fatal error.')


class SkipCacheMtimeChecks(BaseModel):
    __root__: bool = Field(
        ..., description='Skip cache internal consistency checks based on mtime.'
    )


class SkipVersionCheck(BaseModel):
    __root__: bool = Field(
        ...,
        description='Makes mypy use incremental cache data even if it was generated by a different version of mypy. (By default, mypy will perform a version check and regenerate the cache if it was written by older versions of mypy.)',
    )


class SqliteCache(BaseModel):
    __root__: bool = Field(
        ..., description='Use an SQLite database to store the cache.'
    )


class Strict(BaseModel):
    __root__: bool = Field(
        ...,
        description='Enable all optional error checking flags. You can see the list of flags enabled by strict mode in the full `mypy --help` output. The exact list of flags enabled by `strict` may change over time.',
    )


class StrictConcatenate(BaseModel):
    __root__: bool = Field(
        ...,
        description='Make arguments prepended via `Concatenate` be truly positional-only.',
    )


class StrictEquality(BaseModel):
    __root__: bool = Field(
        ...,
        description='Prohibit equality checks, identity checks, and container checks between non-overlapping types.',
    )


class StrictOptional(BaseModel):
    __root__: bool = Field(
        ...,
        description='Enables or disables strict `Optional` checks. If `False`, mypy treats `None` as compatible with every type.',
    )


class UntypedCallsExclude(BaseModel):
    __root__: Union[str, List[str]] = Field(
        ...,
        description='Selectively excludes functions and methods defined in specific packages, modules, and classes from action of `disallow_untyped_calls`. This also applies to all submodules of packages (i.e. everything inside a given prefix). Note, this option does not support per-file configuration, the exclusions list is defined globally for all your code.',
    )


class Verbosity(BaseModel):
    __root__: int = Field(
        ...,
        description='Controls how much debug output will be generated. Higher numbers are more verbose.',
    )


class WarnIncompleteStub(BaseModel):
    __root__: bool = Field(
        ...,
        description='Warns about missing type annotations in typeshed. This is only relevant in combination with `disallow_untyped_defs` or `disallow_incomplete_defs`.',
    )


class WarnNoReturn(BaseModel):
    __root__: bool = Field(
        ...,
        description='Shows errors for missing return statements on some execution paths.',
    )


class WarnReturnAny(BaseModel):
    __root__: bool = Field(
        ...,
        description='Shows a warning when returning a value with type `Any` from a function declared with a non-`Any` return type.',
    )


class WarnUnreachable(BaseModel):
    __root__: bool = Field(
        ...,
        description='Shows a warning when encountering any code inferred to be unreachable or redundant after performing type analysis.',
    )


class WarnUnusedConfigs(BaseModel):
    __root__: bool = Field(
        ...,
        description='Warns about per-module sections in the config file that do not match any files processed when invoking mypy. (This requires turning off incremental mode using `incremental = False`.)',
    )


class WarnUnusedIgnores(BaseModel):
    __root__: bool = Field(
        ..., description='Warns about unneeded `# type: ignore` comments.'
    )


class XmlReport(BaseModel):
    __root__: str = Field(
        ..., description='Causes mypy to generate an XML type checking coverage report.'
    )


class Override(BaseModel):
    class Config:
        extra = Extra.forbid

    module: Union[str, List[str]]
    ignore_missing_imports: Optional[IgnoreMissingImports] = None
    follow_imports: Optional[FollowImports] = 'normal'
    follow_imports_for_stubs: Optional[FollowImportsForStubs] = None
    no_site_packages: Optional[NoSitePackages] = None
    always_true: Optional[AlwaysTrue] = None
    always_false: Optional[AlwaysFalse] = None
    disallow_any_unimported: Optional[DisallowAnyUnimported] = None
    disallow_any_expr: Optional[DisallowAnyExpr] = None
    disallow_any_decorated: Optional[DisallowAnyDecorated] = None
    disallow_any_explicit: Optional[DisallowAnyExplicit] = None
    disallow_any_generics: Optional[DisallowAnyGenerics] = None
    disallow_subclassing_any: Optional[DisallowSubclassingAny] = None
    disallow_untyped_calls: Optional[DisallowUntypedCalls] = None
    untyped_calls_exclude: Optional[UntypedCallsExclude] = None
    disallow_untyped_defs: Optional[DisallowUntypedDefs] = None
    disallow_incomplete_defs: Optional[DisallowIncompleteDefs] = None
    check_untyped_defs: Optional[CheckUntypedDefs] = None
    disallow_untyped_decorators: Optional[DisallowUntypedDecorators] = None
    implicit_optional: Optional[ImplicitOptional] = None
    no_implicit_optional: Optional[NoImplicitOptional] = None
    no_implicit_reexport: Optional[NoImplicitReexport] = None
    strict_optional: Optional[StrictOptional] = None
    warn_unused_ignores: Optional[WarnUnusedIgnores] = None
    warn_no_return: Optional[WarnNoReturn] = None
    warn_return_any: Optional[WarnReturnAny] = None
    warn_unreachable: Optional[WarnUnreachable] = None
    ignore_errors: Optional[IgnoreErrors] = None
    allow_untyped_globals: Optional[AllowUntypedGlobals] = None
    allow_redefinition: Optional[AllowRedefinition] = None
    local_partial_types: Optional[LocalPartialTypes] = None
    disable_error_code: Optional[DisableErrorCode] = None
    enable_error_code: Optional[EnableErrorCode] = None
    implicit_reexport: Optional[ImplicitReexport] = None
    strict_concatenate: Optional[StrictConcatenate] = None
    strict_equality: Optional[StrictEquality] = None
    strict: Optional[Strict] = None
    show_error_context: Optional[ShowErrorContext] = None
    show_column_numbers: Optional[ShowColumnNumbers] = None
    hide_error_codes: Optional[HideErrorCodes] = None
    pretty: Optional[Pretty] = None
    color_output: Optional[ColorOutput] = None
    error_summary: Optional[ErrorSummary] = None
    show_absolute_path: Optional[ShowAbsolutePath] = None
    force_uppercase_builtins: Optional[ForceUppercaseBuiltins] = None
    force_union_syntax: Optional[ForceUnionSyntax] = None
    incremental: Optional[Incremental] = None
    cache_dir: Optional[CacheDir] = None
    sqlite_cache: Optional[SqliteCache] = None
    cache_fine_grained: Optional[CacheFineGrained] = None
    skip_version_check: Optional[SkipVersionCheck] = None
    skip_cache_mtime_checks: Optional[SkipCacheMtimeChecks] = None
    plugins: Optional[Plugins] = None
    pdb: Optional[Pdb] = None
    show_traceback: Optional[ShowTraceback] = None
    raise_exceptions: Optional[RaiseExceptions] = None
    custom_typing_module: Optional[CustomTypingModule] = None
    custom_typeshed_dir: Optional[CustomTypeshedDir] = None
    warn_incomplete_stub: Optional[WarnIncompleteStub] = None
    any_exprs_report: Optional[AnyExprsReport] = None
    cobertura_xml_report: Optional[CoberturaXmlReport] = None
    linecount_report: Optional[LinecountReport] = None
    linecoverage_report: Optional[LinecoverageReport] = None
    lineprecision_report: Optional[LineprecisionReport] = None
    xml_report: Optional[XmlReport] = None
    junit_xml: Optional[JunitXml] = None
    scripts_are_modules: Optional[ScriptsAreModules] = None
    warn_unused_configs: Optional[WarnUnusedConfigs] = None
    verbosity: Optional[Verbosity] = None


class Model(BaseModel):
    class Config:
        extra = Extra.forbid

    mypy_path: Optional[Union[str, List[str]]] = Field(
        None,
        description="Specifies the paths to use, after trying the paths from `MYPYPATH` environment variable. Useful if you'd like to keep stubs in your repo, along with the config file. Multiple paths are always separated with a `:` or `,` regardless of the platform. User home directory and environment variables will be expanded.",
    )
    files: Optional[Union[str, List[str]]] = Field(
        None,
        description='A comma-separated list of paths which should be checked by mypy if none are given on the command line. Supports recursive file globbing using `glob`, where `*` (e.g. `*.py`) matches files in the current directory and `**/` (e.g. `**/*.py`) matches files in any directories below the current one. User home directory and environment variables will be expanded.',
    )
    modules: Optional[Union[str, List[str]]] = Field(
        None,
        description='A comma-separated list of packages which should be checked by mypy if none are given on the command line. Mypy WILL NOT recursively type check any submodules of the provided module.',
    )
    packages: Optional[Union[str, List[str]]] = Field(
        None,
        description='A comma-separated list of packages which should be checked by mypy if none are given on the command line. Mypy WILL recursively type check any submodules of the provided package. This flag is identical to `modules` apart from this behavior.',
    )
    exclude: Optional[Union[str, List[str]]] = Field(
        None,
        description='A regular expression that matches file names, directory names and paths which mypy should ignore while recursively discovering files to check. Use forward slashes (`/`) as directory separators on all platforms.',
    )
    namespace_packages: Optional[bool] = Field(
        True,
        description='Enables PEP 420 style namespace packages. See the corresponding flag `--no-namespace-packages` (https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-no-namespace-packages) for more information.',
    )
    explicit_package_bases: Optional[bool] = Field(
        False,
        description='This flag tells mypy that top-level packages will be based in either the current directory, or a member of the `MYPYPATH` environment variable or `mypy_path` config option. This option is only useful in the absence of `__init__.py`. See Mapping file paths to modules (https://mypy.readthedocs.io/en/stable/running_mypy.html#mapping-paths-to-modules) for details.',
    )
    ignore_missing_imports: Optional[bool] = Field(
        False,
        description='Suppresses error messages about imports that cannot be resolved.',
    )
    follow_imports: Optional[FollowImports] = Field(
        'normal',
        description='Directs what to do with imports when the imported module is found as a `.py` file and not part of the files, modules and packages provided on the command line.',
    )
    follow_imports_for_stubs: Optional[bool] = Field(
        False,
        description='Determines whether to respect the `follow_imports` setting even for stub (`.pyi`) files.',
    )
    python_executable: Optional[str] = Field(
        None,
        description='Specifies the path to the Python executable to inspect to collect a list of available PEP 561 packages (https://mypy.readthedocs.io/en/stable/installed_packages.html#installed-packages). User home directory and environment variables will be expanded. Defaults to the executable used to run mypy.',
    )
    no_site_packages: Optional[bool] = Field(
        False,
        description='Disables using type information in installed packages (see PEP 561). This will also disable searching for a usable Python executable. This acts the same as :option:`--no-site-packages <mypy --no-site-packages>` command line flag.',
    )
    no_silence_site_packages: Optional[bool] = Field(
        False,
        description='Enables reporting error messages generated within installed packages (see PEP 561 for more details on distributing type information). Those error messages are suppressed by default, since you are usually not able to control errors in 3rd party code.',
    )
    python_version: Optional[str] = Field(
        None,
        description='Specifies the Python version used to parse and check the target program. The string should be in the format `MAJOR.MINOR` (for example, `2.7`). The default is the version of the Python interpreter used to run mypy.',
    )
    platform: Optional[str] = Field(
        None,
        description="Specifies the OS platform for the target program, for example `darwin` or `win32` (meaning OS X or Windows, respectively). The default is the current platform as revealed by Python's `sys.platform` variable.",
    )
    always_true: Optional[Union[str, List[str]]] = Field(
        None,
        description='Specifies a list of variables that mypy will treat as compile-time constants that are always true.',
    )
    always_false: Optional[Union[str, List[str]]] = Field(
        None,
        description='Specifies a list of variables that mypy will treat as compile-time constants that are always false.',
    )
    disallow_any_unimported: Optional[bool] = Field(
        False,
        description='Disallows usage of types that come from unfollowed imports (anything imported from an unfollowed import is automatically given a type of `Any`).',
    )
    disallow_any_expr: Optional[bool] = Field(
        False,
        description='Disallows all expressions in the module that have type `Any`.',
    )
    disallow_any_decorated: Optional[bool] = Field(
        False,
        description='Disallows functions that have `Any` in their signature after decorator transformation.',
    )
    disallow_any_explicit: Optional[bool] = Field(
        False,
        description='Disallows explicit `Any` in type positions such as type annotations and generic type parameters.',
    )
    disallow_any_generics: Optional[bool] = Field(
        False,
        description='Disallows usage of generic types that do not specify explicit type parameters.',
    )
    disallow_subclassing_any: Optional[bool] = Field(
        False, description='Disallows subclassing a value of type `Any`.'
    )
    disallow_untyped_calls: Optional[bool] = Field(
        False,
        description='Disallows calling functions without type annotations from functions with type annotations. Note that when used in per-module options, it enables/disables this check INSIDE the module(s) specified, not for functions that come from that module(s).',
    )
    untyped_calls_exclude: Optional[Union[str, List[str]]] = Field(
        None,
        description='Selectively excludes functions and methods defined in specific packages, modules, and classes from action of `disallow_untyped_calls`. This also applies to all submodules of packages (i.e. everything inside a given prefix). Note, this option does not support per-file configuration, the exclusions list is defined globally for all your code.',
    )
    disallow_untyped_defs: Optional[bool] = Field(
        False,
        description='Disallows defining functions without type annotations or with incomplete type annotations (a superset of `disallow_incomplete_defs`).',
    )
    disallow_incomplete_defs: Optional[bool] = Field(
        False,
        description='Disallows defining functions with incomplete type annotations, while still allowing entirely unannotated definitions.',
    )
    check_untyped_defs: Optional[bool] = Field(
        False,
        description='Type-checks the interior of functions without type annotations.',
    )
    disallow_untyped_decorators: Optional[bool] = Field(
        False,
        description='Reports an error whenever a function with type annotations is decorated with a decorator without annotations.',
    )
    implicit_optional: Optional[bool] = Field(
        False,
        description='Causes mypy to treat arguments with a `None` default value as having an implicit `typing.Optional` type.',
    )
    no_implicit_optional: Optional[bool] = Field(
        True, description='Inverse of implicit_optional.'
    )
    no_implicit_reexport: Optional[bool] = Field(
        False,
        description='By default, imported values to a module are treated as exported and mypy allows other modules to import them. This flag changes the behavior to not re-export unless the item is imported using from-as or is included in `__all__`. Note this is always treated as enabled for stub files.',
    )
    strict_optional: Optional[bool] = Field(
        True,
        description='Enables or disables strict `Optional` checks. If `False`, mypy treats `None` as compatible with every type.',
    )
    warn_redundant_casts: Optional[bool] = Field(
        False, description='Warns about casting an expression to its inferred type.'
    )
    warn_unused_ignores: Optional[bool] = Field(
        False, description='Warns about unneeded `# type: ignore` comments.'
    )
    warn_no_return: Optional[bool] = Field(
        True,
        description='Shows errors for missing return statements on some execution paths.',
    )
    warn_return_any: Optional[bool] = Field(
        False,
        description='Shows a warning when returning a value with type `Any` from a function declared with a non-`Any` return type.',
    )
    warn_unreachable: Optional[bool] = Field(
        False,
        description='Shows a warning when encountering any code inferred to be unreachable or redundant after performing type analysis.',
    )
    ignore_errors: Optional[bool] = Field(
        False, description='Ignores all non-fatal errors.'
    )
    allow_untyped_globals: Optional[bool] = Field(
        False,
        description='Causes mypy to suppress errors caused by not being able to fully infer the types of global and class variables.',
    )
    allow_redefinition: Optional[bool] = Field(
        False,
        description='Allows variables to be redefined with an arbitrary type, as long as the redefinition is in the same block and nesting level as the original definition.',
    )
    local_partial_types: Optional[bool] = Field(
        False,
        description='Disallows inferring variable type for `None` from two assignments in different scopes. This is always implicitly enabled when using the mypy daemon (https://mypy.readthedocs.io/en/stable/mypy_daemon.html).',
    )
    disable_error_code: Optional[Union[str, List[str]]] = Field(
        None, description='Allows disabling one or multiple error codes globally.'
    )
    enable_error_code: Optional[Union[str, List[str]]] = Field(
        None, description='Allows enabling one or multiple error codes globally.'
    )
    implicit_reexport: Optional[bool] = Field(
        True,
        description='By default, imported values to a module are treated as exported and mypy allows other modules to import them. When false, mypy will not re-export unless the item is imported using from-as or is included in `__all__`. Note that mypy treats stub files as if this is always disabled.',
    )
    strict_concatenate: Optional[bool] = Field(
        False,
        description='Make arguments prepended via `Concatenate` be truly positional-only.',
    )
    extra_checks: Optional[bool] = Field(
        False,
        description='Enable additional checks that are technically correct but impractical.',
    )
    strict_equality: Optional[bool] = Field(
        False,
        description='Prohibit equality checks, identity checks, and container checks between non-overlapping types.',
    )
    strict: Optional[bool] = Field(
        False,
        description='Enable all optional error checking flags. You can see the list of flags enabled by strict mode in the full `mypy --help` output. The exact list of flags enabled by `strict` may change over time.',
    )
    show_error_context: Optional[bool] = Field(
        False, description='Prefixes each error with the relevant context.'
    )
    show_column_numbers: Optional[bool] = Field(
        False, description='Shows column numbers in error messages.'
    )
    hide_error_codes: Optional[bool] = Field(
        False,
        description='Hides error codes (https://mypy.readthedocs.io/en/stable/error_codes.html#error-codes) in error messages.',
    )
    pretty: Optional[bool] = Field(
        False,
        description='Use visually nicer output in error messages: use soft word wrap, show source code snippets, and show error location markers.',
    )
    color_output: Optional[bool] = Field(
        True, description='Shows error messages with color enabled.'
    )
    error_summary: Optional[bool] = Field(
        True, description='Shows a short summary line after error messages.'
    )
    show_absolute_path: Optional[bool] = Field(
        False, description='Show absolute paths to files.'
    )
    force_uppercase_builtins: Optional[bool] = Field(
        False,
        description='Always use `List` instead of `list` in error messages, even on Python 3.9+.',
    )
    force_union_syntax: Optional[bool] = Field(
        False,
        description='Always use `Union[]` and `Optional[]` for union types in error messages (instead of the `|` operator), even on Python 3.10+.',
    )
    incremental: Optional[bool] = Field(
        True,
        description='Enables incremental mode (https://mypy.readthedocs.io/en/stable/command_line.html#incremental).',
    )
    cache_dir: Optional[str] = Field(
        '.mypy_cache',
        description='Specifies the location where mypy stores incremental cache info. User home directory and environment variables will be expanded. This setting will be overridden by the `MYPY_CACHE_DIR` environment variable.',
    )
    sqlite_cache: Optional[bool] = Field(
        False, description='Use an SQLite database to store the cache.'
    )
    cache_fine_grained: Optional[bool] = Field(
        False,
        description='Include fine-grained dependency information in the cache for the mypy daemon (https://mypy.readthedocs.io/en/stable/mypy_daemon.html).',
    )
    skip_version_check: Optional[bool] = Field(
        False,
        description='Makes mypy use incremental cache data even if it was generated by a different version of mypy. (By default, mypy will perform a version check and regenerate the cache if it was written by older versions of mypy.)',
    )
    skip_cache_mtime_checks: Optional[bool] = Field(
        False, description='Skip cache internal consistency checks based on mtime.'
    )
    plugins: Optional[Union[str, List[str]]] = Field(
        None, description='A comma-separated list of mypy plugins.'
    )
    pdb: Optional[bool] = Field(
        False,
        description='Invokes `pdb` (https://docs.python.org/3/library/pdb.html) on fatal error.',
    )
    show_traceback: Optional[bool] = Field(
        False, description='Shows traceback on fatal error.'
    )
    raise_exceptions: Optional[bool] = Field(
        False, description='Raise exception on fatal error.'
    )
    custom_typing_module: Optional[str] = Field(
        None,
        description='Specifies a custom module to use as a substitute for the `typing` module.',
    )
    custom_typeshed_dir: Optional[str] = Field(
        None,
        description='This specifies the directory where mypy looks for standard library typeshed stubs, instead of the typeshed that ships with mypy. This is primarily intended to make it easier to test typeshed changes before submitting them upstream, but also allows you to use a forked version of typeshed.',
    )
    warn_incomplete_stub: Optional[bool] = Field(
        False,
        description='Warns about missing type annotations in typeshed. This is only relevant in combination with `disallow_untyped_defs` or `disallow_incomplete_defs`.',
    )
    any_exprs_report: Optional[str] = Field(
        None,
        description='Causes mypy to generate a text file report documenting how many expressions of type `Any` are present within your codebase.',
    )
    cobertura_xml_report: Optional[str] = Field(
        None,
        description='Causes mypy to generate a Cobertura XML type checking coverage report.',
    )
    linecount_report: Optional[str] = Field(
        None,
        description='Causes mypy to generate a text file report documenting the functions and lines that are typed and untyped within your codebase.',
    )
    linecoverage_report: Optional[str] = Field(
        None,
        description="Causes mypy to generate a JSON file that maps each source file's absolute filename to a list of line numbers that belong to typed functions in that file.",
    )
    lineprecision_report: Optional[str] = Field(
        None,
        description='Causes mypy to generate a flat text file report with per-module statistics of how many lines are typechecked etc.',
    )
    xml_report: Optional[str] = Field(
        None,
        description='Causes mypy to generate an XML type checking coverage report.',
    )
    junit_xml: Optional[str] = Field(
        None,
        description='Causes mypy to generate a JUnit XML test result document with type checking results. This can make it easier to integrate mypy with continuous integration (CI) tools.',
    )
    scripts_are_modules: Optional[bool] = Field(
        False,
        description='Makes script `x` become module `x` instead of `__main__`. This is useful when checking multiple scripts in a single run.',
    )
    warn_unused_configs: Optional[bool] = Field(
        False,
        description='Warns about per-module sections in the config file that do not match any files processed when invoking mypy. (This requires turning off incremental mode using `incremental = False`.)',
    )
    verbosity: Optional[int] = Field(
        0,
        description='Controls how much debug output will be generated. Higher numbers are more verbose.',
    )
    show_error_codes: Optional[bool] = Field(
        True,
        description='DEPRECATED and UNDOCUMENTED: Now defaults to true, use `hide_error_codes` if you need to disable error codes instead.',
    )
    show_error_code_links: Optional[bool] = Field(
        False, description='UNDOCUMENTED: show links for error codes.'
    )
    disable_bytearray_promotion: Optional[bool] = Field(
        False,
        description='UNDOCUMENTED. Disables automatic promotion of `bytearray` to `bytes` type. Is set to `true` in strict mode.',
    )
    disable_memoryview_promotion: Optional[bool] = Field(
        False,
        description='UNDOCUMENTED. Disables automatic promotion of `memoryview` to `bytes` type. Is set to `true` in strict mode.',
    )
    enable_incomplete_feature: Optional[Union[str, List[str]]] = Field(
        None,
        description='Enable a preview of incomplete features that are not yet enabled by default by the current version of mypy. Note that it is not guaranteed that all features will be ultimately enabled by default.',
    )
    overrides: Optional[List[Override]] = None
